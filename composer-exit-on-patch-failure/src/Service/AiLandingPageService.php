<?php

namespace Drupal\drupalx_ai\Service;

use Drupal\Core\Config\ConfigFactoryInterface;
use Drupal\Core\Entity\EntityTypeManagerInterface;
use Drupal\Core\Logger\LoggerChannelFactoryInterface;
use Drupal\Core\Url;
use Drupal\node\Entity\Node;
use Drupal\paragraphs\Entity\Paragraph;

/**
 * Service for creating AI-generated landing pages.
 */
final class AiLandingPageService {

  /**
   * The config factory.
   *
   * @var \Drupal\Core\Config\ConfigFactoryInterface
   */
  private $configFactory;

  /**
   * Constructs a new AiLandingPageService object.
   *
   * @param \Drupal\Core\Entity\EntityTypeManagerInterface $entityTypeManager
   *   The entity type manager.
   * @param \Drupal\Core\Logger\LoggerChannelFactoryInterface $loggerFactory
   *   The logger factory.
   * @param \Drupal\drupalx_ai\Service\MockLandingPageService $mockLandingPageService
   *   The mock landing page service.
   * @param \Drupal\drupalx_ai\Service\AiModelApiService $aiModelApiService
   *   The AI Model API service.
   * @param \Drupal\drupalx_ai\Service\ParagraphStructureService $paragraphStructureService
   *   The paragraph structure service.
   * @param \Drupal\Core\Config\ConfigFactoryInterface $configFactory
   *   The config factory.
   */
  public function __construct(
    private readonly EntityTypeManagerInterface $entityTypeManager,
    private readonly LoggerChannelFactoryInterface $loggerFactory,
    private readonly MockLandingPageService $mockLandingPageService,
    private readonly AiModelApiService $aiModelApiService,
    private readonly ParagraphStructureService $paragraphStructureService,
    ConfigFactoryInterface $configFactory,
  ) {
    $this->configFactory = $configFactory;
  }

  /**
   * Generates AI content for a landing page based on a description.
   *
   * @param string $description
   *   The user-provided description of the desired landing page.
   *
   * @return array|null
   *   An array of paragraph data generated by AI, or null if generation failed.
   */
  public function generateAiContent(string $description): ?array {
    $paragraphStructures = $this->paragraphStructureService->getParagraphStructures(TRUE);
    $prompt = $this->buildPrompt($description, $paragraphStructures);

    $tools = [
      [
        'name' => 'generate_ai_landing_page',
        'description' => 'Generate an AI-driven landing page structure with content',
        'input_schema' => [
          'type' => 'object',
          'properties' => [
            'page_title' => [
              'type' => 'string',
              'description' => 'Create title for the landing page',
            ],
            'paragraphs' => [
              'type' => 'array',
              'items' => [
                'type' => 'object',
                'properties' => [
                  'type' => [
                    'type' => 'string',
                    'description' => 'The type of the paragraph',
                  ],
                  'fields' => [
                    'type' => 'object',
                    'additionalProperties' => TRUE,
                    'description' => 'The fields of the paragraph with their values',
                  ],
                ],
                'required' => ['type', 'fields'],
              ],
            ],
          ],
          'required' => ['paragraphs', 'page_title'],
        ],
      ],
    ];

    $result = $this->aiModelApiService->callAiApi($prompt, $tools, 'generate_ai_landing_page');

    if (is_array($result) && isset($result['paragraphs'])) {
      // If paragraphs is a string, attempt to decode it.
      if (is_string($result['paragraphs'])) {
        try {
          $decodedParagraphs = json_decode($result['paragraphs'], TRUE, 512, JSON_THROW_ON_ERROR);
          if (is_array($decodedParagraphs)) {
            $result['paragraphs'] = $decodedParagraphs;
          } else {
            $this->loggerFactory->get('drupalx_ai')->error('Failed to decode paragraphs data: not an array after decoding');
            return NULL;
          }
        } catch (\JsonException $e) {
          $this->loggerFactory->get('drupalx_ai')->error('Failed to decode paragraphs JSON: @message', ['@message' => $e->getMessage()]);
          return NULL;
        }
      }

      // Validate the structure.
      if (!is_array($result['paragraphs'])) {
        $this->loggerFactory->get('drupalx_ai')->error('Paragraphs data is not an array');
        return NULL;
      }

      return $result;
    }

    $this->loggerFactory->get('drupalx_ai')->error('AI content generation failed or returned unexpected result');
    return NULL;
  }

  /**
   * Builds the prompt for the AI API.
   *
   * @param string $description
   *   The user-provided description of the desired landing page.
   * @param array $paragraphStructures
   *   The available paragraph structures.
   *
   * @return string
   *   The constructed prompt.
   */
  private function buildPrompt(string $description, array $paragraphStructures): string {
    $prompt = "Generate an AI-driven landing page structure with content based on the following description:\n\n";
    $prompt .= "$description\n\n";
    $prompt .= "CRITICAL: The page_title is required. Create a compelling and relevant title for the landing page based on the content.\n\n";
    $prompt .= "CRITICAL: The paragraphs field MUST be an array, not a string. Do not stringify the paragraphs array.\n\n";
    $prompt .= "Available paragraph types and their structures (in JSON format):\n\n";

    $prompt .= json_encode($paragraphStructures, JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE) . "\n\n";

    $prompt .= "Understanding the JSON structure:\n";
    $prompt .= "- 'b' represents the bundle (paragraph type)\n";
    $prompt .= "- 'f' is an array of fields, where each field has:\n";
    $prompt .= "  - 't': field type\n";
    $prompt .= "  - 'n': field name\n";
    $prompt .= "  - 'r': required (boolean)\n";
    $prompt .= "  - 'c': cardinality (-1 for unlimited, or a positive integer)\n";
    $prompt .= "  - 'e': an example value for the field\n";
    $prompt .= "  - 'o': (for list_string fields only) an array of allowed options\n\n";

    $allowedParagraphTypes = $this->mockLandingPageService->getAllowedParagraphTypes('node', 'landing', 'field_content');
    $prompt .= "IMPORTANT: Only use the following paragraph types as top-level array of paragraphs:\n";
    $prompt .= implode(", ", $allowedParagraphTypes) . "\n\n";

    $prompt .= "CRITICAL REQUIREMENTS:\n";
    $prompt .= "1. The 'bullet' paragraph is never in the top level array of paragraphs.\n";
    $prompt .= "2. Use a variety of paragraph types, do not overuse the same types over and over.\n";
    $prompt .= "3. For fields named 'field_icon', you MUST only use valid Lucide icon names (e.g. 'arrow-right').\n";
    $prompt .= "4. When generating the landing page structure, ensure that ONLY the allowed paragraph types listed above are used as top-level paragraphs.\n";
    $prompt .= "5. Other paragraph types can be used as nested paragraphs within these allowed types if the structure permits.\n";
    $prompt .= "6. Every paragraph, including sub-paragraphs (such as accordion items or pricing cards), must have a 'type' property.\n";
    $prompt .= "7. For entity reference fields, use appropriate existing entity names or IDs.\n";
    $prompt .= "8. For viewsreference fields, use existing view names and display IDs.\n";
    $prompt .= "9. For list_string fields, choose only from the provided options in the 'o' array.\n";
    $prompt .= "10. In field_features_text do not include any characters for bullets, only plain text separated by new lines.\n";
    $prompt .= "11. Stat items should always have a title value.\n";
    $prompt .= "12. The text paragraph does not have a field_summary field.\n";
    $prompt .= "13. For logo collection limit max to 7 media items.\n\n";

    $prompt .= "Example structure (note that paragraphs is an array, not a string):\n";
    $prompt .= "{\n";
    $prompt .= "  \"page_title\": \"Our Amazing Service\",\n";
    $prompt .= "  \"paragraphs\": [\n";
    $prompt .= "    {\n";
    $prompt .= "      \"type\": \"hero\",\n";
    $prompt .= "      \"fields\": {\n";
    $prompt .= "        \"field_heading\": \"Welcome to Our Service\",\n";
    $prompt .= "        \"field_hero_layout\": \"image_bottom\",\n";
    $prompt .= "        \"field_summary\": \"We provide top-notch solutions for your needs.\",\n";
    $prompt .= "        \"field_media\": \"Technology\"\n";
    $prompt .= "      }\n";
    $prompt .= "    },\n";
    $prompt .= "    {\n";
    $prompt .= "      \"type\": \"accordion\",\n";
    $prompt .= "      \"fields\": {\n";
    $prompt .= "        \"field_title\": \"Frequently Asked Questions\",\n";
    $prompt .= "        \"field_accordion_item\": [\n";
    $prompt .= "          {\n";
    $prompt .= "            \"type\": \"accordion_item\",\n";
    $prompt .= "            \"fields\": {\n";
    $prompt .= "              \"field_title\": \"What services do you offer?\",\n";
    $prompt .= "              \"field_body\": \"We offer a wide range of services including...\"\n";
    $prompt .= "            }\n";
    $prompt .= "          }\n";
    $prompt .= "        ]\n";
    $prompt .= "      }\n";
    $prompt .= "    }\n";
    $prompt .= "  ]\n";
    $prompt .= "}\n\n";

    $prompt .= "Please generate a landing page structure using these paragraph types. Fill in realistic content for each field. Use a variety of paragraph types to create an engaging and diverse landing page, while adhering to the allowed top-level paragraph types. When you're done, call the generate_ai_landing_page function with the generated structure.\n";

    return $prompt;
  }

  /**
   * Creates a landing page node with AI-generated content.
   *
   * @param string $page_title
   *   Name of the landing page.
   * @param array $paragraphs
   *   An array of paragraph data generated by AI.
   *
   * @return string|null
   *   The URL of the created node, or null if creation failed.
   */
  public function createLandingNodeWithAiContent(string $page_title, array $paragraphs): ?string {
    $node = Node::create([
      'type' => 'landing',
      'title' => $page_title ?? 'AI Generated Landing Page',
      'field_hide_page_title' => 1,
      'status' => 1,
    ]);

    foreach ($paragraphs as $paragraphData) {
      $paragraph = $this->createParagraphFromGeneratedContent($paragraphData);
      if ($paragraph) {
        $node->get('field_content')->appendItem($paragraph);
      }
    }

    try {
      $node->save();
      $url = Url::fromRoute('entity.node.edit_form', ['node' => $node->id()]);
      return $url->setAbsolute()->toString();
    }
    catch (\Exception $e) {
      $this->loggerFactory->get('drupalx_ai')->error('Failed to create landing page: @message', ['@message' => $e->getMessage()]);
      return NULL;
    }
  }

  /**
   * Creates a paragraph entity from generated content.
   *
   * @param array $paragraphData
   *   The generated data for a single paragraph.
   * @param string $parentType
   *   The type of the parent paragraph (optional).
   *
   * @return \Drupal\paragraphs\Entity\Paragraph|null
   *   The created paragraph entity, or null if creation failed.
   */
  private function createParagraphFromGeneratedContent(array $paragraphData, string $parentType = ''): ?Paragraph {
    try {
      // Handle the case where '{' is used instead of 'type'.
      if (!isset($paragraphData['type']) && isset($paragraphData['{'])) {
        $paragraphData['type'] = $paragraphData['{'];
        unset($paragraphData['{']);
      }

      // If type is missing for nested paragraphs, try to determine it from parent
      if (!isset($paragraphData['type']) && !empty($parentType)) {
        // Common parent-child relationships
        $childTypes = [
          'accordion' => 'accordion_item',
          'pricing' => 'pricing_card',
          'stats' => 'stat_item',
          'features' => 'feature_item',
          'tabs' => 'tab_item',
          'carousel' => 'carousel_item',
          'timeline' => 'timeline_item',
          'gallery' => 'gallery_item',
        ];

        // First check if we have a predefined child type
        if (isset($childTypes[$parentType])) {
          $paragraphData['type'] = $childTypes[$parentType];
        }
        // Otherwise, fallback to parent type + '_item'
        else {
          $paragraphData['type'] = $parentType . '_item';
        }
      }

      if (!isset($paragraphData['type'])) {
        $this->loggerFactory->get('drupalx_ai')->warning('Paragraph type is missing. Skipping this paragraph.');
        return NULL;
      }

      $paragraph = Paragraph::create([
        'type' => $paragraphData['type'],
      ]);

      $fieldDefinitions = $paragraph->getFieldDefinitions();

      foreach ($paragraphData['fields'] as $fieldName => $fieldValue) {
        $fieldDefinition = $fieldDefinitions[$fieldName] ?? NULL;

        // Skip this svg field.
        if ($fieldName === 'field_logo') {
          continue;
        }
        elseif ($fieldDefinition && $fieldDefinition->getType() === 'entity_reference' &&
                $fieldDefinition->getSetting('target_type') === 'media') {
          if (is_string($fieldValue)) {
            $media = $this->createOrFetchMedia($this->preprocessImageSearchTerm($fieldValue));
            if ($media) {
              $paragraph->set($fieldName, $media);
            }
          }
          elseif (is_array($fieldValue)) {
            $mediaItems = [];
            foreach ($fieldValue as $value) {
              $media = $this->createOrFetchMedia($this->preprocessImageSearchTerm($value));
              if ($media) {
                $mediaItems[] = $media;
              }
            }
            if (!empty($mediaItems)) {
              $paragraph->set($fieldName, $mediaItems);
            }
          }
        }
        elseif (is_array($fieldValue) &&
                (isset($fieldValue[0]['type']) ||
                isset($fieldValue[0]['{']) ||
                ($fieldDefinition?->getType() === 'entity_reference_revisions' &&
                 $fieldDefinition->getSetting('target_type') === 'paragraph'))) {
          // This is likely a nested paragraph field.
          $nestedParagraphs = [];
          foreach ($fieldValue as $nestedParagraphData) {
            // If the nested data is just a string or simple value, wrap it in a proper structure
            if (!is_array($nestedParagraphData) || (!isset($nestedParagraphData['type']) && !isset($nestedParagraphData['fields']))) {
              $nestedParagraphData = [
                'fields' => ['field_text' => $nestedParagraphData],
              ];
            }

            // Pass the current paragraph type as the parent type for nested paragraphs
            $nestedParagraph = $this->createParagraphFromGeneratedContent(
              $nestedParagraphData,
              $paragraphData['type']
            );
            if ($nestedParagraph) {
              $nestedParagraphs[] = $nestedParagraph;
            }
          }
          if (!empty($nestedParagraphs)) {
            $paragraph->set($fieldName, $nestedParagraphs);
          }
        }
        elseif ($fieldName === 'field_icon') {
          $iconName = $this->paragraphStructureService->getBestIconMatch($fieldValue);
          $paragraph->set($fieldName, $iconName);
        }
        elseif ($fieldName === 'field_features_text') {
          $cleanedFieldValue = preg_replace('/^[\W_]+/m', '', $fieldValue);
          $paragraph->set($fieldName, $cleanedFieldValue);
        }
        elseif ($fieldName === 'field_hero_layout') {
          $paragraph->set($fieldName, !empty($fieldValue) ? $fieldValue : 'image_top');
        }
        elseif ($fieldName === 'field_text_layout') {
          $paragraph->set($fieldName, !empty($fieldValue) ? $fieldValue : 'left');
        }
        elseif ($fieldName === 'field_sidebyside_layout') {
          $paragraph->set($fieldName, !empty($fieldValue) ? $fieldValue : 'left');
        }
        else {
          if ($fieldDefinition && in_array($fieldDefinition->getType(), ['text', 'text_long', 'text_with_summary'])) {
            // Handle text fields that can come in either as string or array
            // format.
            if (is_array($fieldValue) && isset($fieldValue['value'])) {
              // If it's an array with 'value' key, use that value.
              $textValue = $fieldValue['value'];
              // Get the format if provided, default to 'basic_html'.
              $format = $fieldValue['format'] ?? 'basic_html';
              $paragraph->set($fieldName, [
                'value' => $this->convertRichTextFormat($textValue),
                'format' => $format,
              ]);
            } else {
              // If it's a string or any other format, convert it directly.
              $paragraph->set($fieldName, [
                'value' => $this->convertRichTextFormat((string) $fieldValue),
                'format' => 'basic_html',
              ]);
            }
          }
          else {
            // For non-text fields, set the value directly.
            $paragraph->set($fieldName, $fieldValue);
          }
        }
      }

      $paragraph->save();
      return $paragraph;
    }
    catch (\Exception $e) {
      $this->loggerFactory->get('drupalx_ai')->error('Failed to create paragraph: @message', ['@message' => $e->getMessage()]);
      return NULL;
    }
  }

  /**
   * Converts markdown-like syntax and newlines in rich text.
   */
  private function convertRichTextFormat(string $text): string {
    // Convert **text** to <strong>text</strong>.
    $text = preg_replace('/\*\*(.*?)\*\*/', '<strong>$1</strong>', $text);

    // Convert consecutive dash-prefixed lines to an unordered list.
    $text = preg_replace_callback(
      '/(?:^|\n)(-\s*.*(?:\n|$))+/',
      function ($matches) {
        $items = preg_split('/\n-\s*/', trim($matches[0]));
        $items = array_filter(array_map('trim', $items));
        return '<ul><li>' . implode('</li><li>', array_map(function ($item) {
          return ltrim($item, '- ');
        }, $items)) . '</li></ul>';
      },
      $text
    );

    // Convert remaining single newlines to <br> tags.
    $text = preg_replace('/(?<!\n)\n(?!\n)/', '<br>', $text);

    return $text;
  }

  /**
   * Preprocesses an image search term.
   *
   * @param mixed $term
   *   The search term to preprocess.
   *
   * @return string
   *   The preprocessed search term.
   */
  private function preprocessImageSearchTerm(mixed $term): string {
    if (is_array($term)) {
      // Flatten the array and convert all elements to strings.
      $term = array_map(function ($item) {
        return is_array($item) ? implode(' ', $item) : (string) $item;
      }, $term);
      $term = implode(' ', $term);
    }

    $term = (string) $term;
    $term = trim($term);
    $term = strtolower($term);
    return preg_replace('/[^a-z0-9\s]/', ' ', $term);
  }

  /**
   * Creates or fetches a media entity based on a search term.
   *
   * @param string $searchTerm
   *   The search term to use for finding or creating media.
   *
   * @return int|null
   *   The media entity ID if successful, null otherwise.
   */
  private function createOrFetchMedia(string $searchTerm) {
    $config = $this->configFactory->get('drupalx_ai.settings');
    $imageGenerator = $config->get('image_generator') ?: 'placeholder';

    try {
      $newMedia = NULL;
      if ($imageGenerator === 'unsplash') {
        $newMedia = (int) $this->mockLandingPageService->createMediaEntityFromUnsplash($searchTerm);
      }
      elseif ($imageGenerator === 'pexels') {
        $newMedia = (int) $this->mockLandingPageService->createMediaEntityFromPexels($searchTerm);
      }
      elseif ($imageGenerator === 'tavily') {
        $newMedia = $this->mockLandingPageService->createMediaEntityFromTavily($searchTerm);
      }

      // Default to placeholder image.
      if (empty($newMedia)) {
        $newMedia = (int) $this->mockLandingPageService->getMediaEntityPlaceholder($searchTerm);
      }

      if ($newMedia) {
        $this->loggerFactory->get('drupalx_ai')->info('Successfully created new media entity for search term: @term using @generator', [
          '@term' => $searchTerm,
          '@generator' => $imageGenerator,
        ]);
        return $newMedia;
      }
      $this->loggerFactory->get('drupalx_ai')->warning('Failed to create new media entity for search term: @term using @generator', [
        '@term' => $searchTerm,
        '@generator' => $imageGenerator,
      ]);
    }
    catch (\Exception $e) {
      $this->loggerFactory->get('drupalx_ai')->error('Exception while creating media entity: @message', ['@message' => $e->getMessage()]);
    }

    // If creation fails or returns null, fall back to finding an existing media item.
    $mediaStorage = $this->entityTypeManager->getStorage('media');
    $existingMedia = $mediaStorage->loadByProperties([
      'name' => $searchTerm,
      'bundle' => 'image',
    ]);

    if (!empty($existingMedia)) {
      return reset($existingMedia)->id();
    }

    // If no existing media found either, return null.
    return NULL;
  }

}
